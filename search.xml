<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IDEA&Android Studio插件开发相关介绍]]></title>
    <url>%2F2018%2F09%2F03%2FIDEA-Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文由谷轩宇(guxuanyu@jd.com)编写。作者2018年加入jd安卓开发岗位，目前效力于通天塔技术开放组。如有错漏、意见和建议，请联系作者。还望指正，谢谢。 是否曾经被ide重复繁琐的操作所困扰，又或者没有心仪的UI控件而难受。那么请阅读这篇文章，掌握idea插件的开发流程，开发属于自己的插件，造福开源社区。开发前请做好相关准备工作： 安装Java SDK什么的……不做解释 掌握Java语言，最好会Kotlin，因为IDEA已经有一部分用Kotlin改写了 下载IDEA社区版（Community）并安装，Android Studio插件开发同样需要下载IDEA，因为Android Studio基于IDEA并且精简掉了插件开发包地址 https://www.jetbrains.com/idea/download下载分为发行和社区版，因为社区版是开源的，所以用这个（后续需要看源码） 下载或clone IDEA的社区版源码地址 https://github.com/JetBrains/intellij-community 打开IDEA SDK的官方文档（要知道啃了几天源码突然才知道原来有文档这是事实是很崩溃的）地址 http://www.jetbrains.org/intellij/sdk/docs 入门篇都准备好了，那就进入正题 一.创建新的插件项目类型就选择IntelliJ Platform Plugin，然后一直下一步 二.新建一个Action先在src文件夹建个packge，取名随意，在packge里新建action需要填4个内容和选择一个Groups，分别是 Action ID ：action的唯一标识，建议 包名.类名Class Name ：创建的Action类名Name ：action显示的文字Description ：描述Groups ：插件属于哪部分，可以定位插件的显示位置 ok之后，plugin.xml会自动加入刚刚创建的action &lt;actions&gt; &lt;!-- Add your actions here --&gt; &lt;action id=&quot;xxx&quot; class=&quot;xxx&quot; text=&quot;xxx&quot;&gt; &lt;add-to-group group-id=&quot;xxx&quot; anchor=&quot;last&quot;/&gt; &lt;/action&gt; &lt;/actions&gt; anchor代表插件相对于组的位置的位置，有以下几种 first：放在最前面last：放在最后before：放在relative-to-action属性指定的ID的前面after：放在relative-to-action属性指定的ID的后面 例如本例Group ID选择了，anchor选了last 最后插件就会在git块的这里出现 运行后插件可以出现了，但这时候点击是没有反应的，进入下一步 三. 重写public void actionPerformed(AnActionEvent e)方法先写个简单的hello world @Override public void actionPerformed(AnActionEvent e) { Project project=event.getProject(); Messages.showMessageDialog(project,&quot;hello world&quot;,&quot;mytitle&quot;,Messages.getInformationIcon()); } 点击三角运行 正常会打开新的idea窗口，随便打开个项目找到刚才的插件位置，点击，不出意外会弹出一个hello world的提示窗口了。 插件开发的过程大概如此，但是我们开发，肯定不是一个弹窗就解决需求的。由于开发需求的多样性，没法在一篇文章介绍所有api，所以在下面的部分，我将介绍IDEA开发的一些统一标准要求。 进阶篇IDEA官方开发者封装了大量易用的api，由于官方文档介绍很笼统，看过了仅有的文档，只能根据要开发的插件功能，去定位官方的源码相似功能部分，然后模仿着写。下面给出的一些经验，开发过程可能有的用不到，但是一定会对你大致理解整套系统有所帮助 一. 在event线程操作UI这点很多平台都有这种规定，后台线程是不能操作UI的，Android中使用的是消息Handler机制，在IDEA中也有类似的消息机制。在event线程中不要进行耗时操作（例如网络，IO），耗时操作要放在后台线程。在后台线程获取到数据后，可以使用下面方式来更新UI。（还有其他方法，这里仅介绍一种) ApplicationManager.getApplication().invokeLater(new Runnable() { @Override public void run() { // update UI } }); 二. 如何开启一个后台任务？不仅限于此，这里介绍一种方法，可以使用ProgressManager来开启 ProgressManager.getInstance().XXXX(new Runnable()); 补全后可以看到很多方法，选择合适的调用即可。 三. 如何开启进度条任务（类似于构建，ide底下会出进度条）创建自定义类MyTask继承于Task.Backgroundable，并重写run方法，run方法在后台线程执行，调用时可以如下 new BackgroundTaskQueue(project, &quot;my-task-name&quot;).run(new MyTask()); 四. 什么是虚拟文件系统VFS（VirtualFileSystem）？官方文档地址: http://www.jetbrains.org/intellij/sdk/docs/basics/architectural_overview/files.html看代码时可能会经常看见VirtualFile，初次见肯定会疑惑，简单介绍一下（摘自官档） 虚拟文件系统（VFS）是IntelliJ Platform的一个组件，它封装了用于处理文件的大部分活动。它有以下主要用途： 提供用于处理文件的通用API，无论其实际位置如何（在磁盘上，存档中，在HTTP服务器上，或者git上等） 在检测到修改时跟踪文件修改并提供文件内容的新旧版本。 提供将附加持久数据与VFS中的文件相关联的可能性。 看一下VirtualFileSystem实例的方法，大概有以下几项：刷新、获取VirtualFile、添加监听等作用。 比较常用的是VirtualFile，看一下实例方法 可以看到我们常用的文件操作基本都在这里。而与之相对应的有个类叫 Document ，这两个是不同的概念，Document 只能用于文本的文档，而且对应的是实例文件。VirtualFile是虚拟的文件，既可用于文本也可用于二进制文件。 五. 什么是程序结构接口PSI (Program Structure Interface)? 程序结构接口，通常称为PSI，是IntelliJ平台中的一个层，负责解析文件并创建支持平台许多功能的语法和语义代码模型。(摘自官档) 也就是说对特定语言语法树，符号解析等可以使用PSI，如果有此需要，可以参考https://www.jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi.html 六. UI相关（用户界面组件） IntelliJ平台包含大量自定义Swing组件。在插件中使用这些组件将确保您的插件与IDE的其余部分的UI一致并且与其一致，并且与使用默认Swing组件相比，通常可以减少代码大小。列举一些 Tool Windows 对话框 Dialogs 弹出窗口 Popups 通知 Notifications 文件和类选择器 File and Class Choosers 编辑器组件 Editor Components 列表和树控件 List and Tree Controls 以及其他很多很多 可以参考http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/user_interface_components.html 总结：其中VFS和PSI是众多模块中比较核心的部分，开发过程中也建议参考其他开源插件的源码，多看多想，相信读者在开发过程中会有不小的收获。 参考文献： AndroidStudio插件开发（Hello World篇） by huachao1001 IDEA官方文档 IDEA社区版Github]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.2预览版的新特性]]></title>
    <url>%2F2018%2F07%2F18%2FAndroid-Studio-3-2%E9%A2%84%E8%A7%88%E7%89%88%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本文原文为New features in Android Studio Preview，原文更新版本为2018年5月29。由刘耀锴(liuyaokai AT jd.com，Wechat: kylelyk12)结合Google Translate进行翻译、编辑和排版。如有错漏、意见和建议，请联系译者。还望指正，谢谢。 Android Studio 3.1.2已经在稳定渠道中发布。 点此下载。 最新的预览版本是Android Studio 3.2。 此文介绍了该预览版的新功能和相关更改。 这些新功能已在最新的金丝雀（Canary）版本中提供，但可能尚未在测试版渠道中提供。 如果您在使用Android Studio的预览版本时遇到任何问题，请告诉我们。 您的错误报告将有助于改进Android Studio。 有关发布的最新消息（包括每个发行版中重要的修复点），请参阅更新日志。 新的辅助面板 Android Studio 3.2提供了一个新的辅助面板Assistant，可以通知您Android Studio相关的最新更新。 启动Android Studio时，如果检测到有新信息，该面板将会打开并展示新信息。 您还可以通过 Help &gt; What’s new in Android Studio 来打开Assistant面板。 Android Jetpack 喷气背包 Android Jetpack能加速Android程序开发，它通过组件、工具和指导说明来帮您去除重复的任务，使您能够更快、更轻松地构建高质量、可测试的应用。为了支持Jetpack，Android Studio更新了以下内容。更多信息请参阅Jetpack文档。 Navigation Editor 导航编辑器新的导航编辑器与喷气背包Jetpack中的导航组件相集成，为创建应用的导航结构提供图形视图。 导航编辑器简化了应用内页面之间跳转的设计和实现。 要了解更多信息，请阅读导航编辑器文档。 AndroidX 重构 作为Jetpack的一部分，我们正在使用androidx命名空间请阅读，将Android支持库（Android Support Libraries）重构为新的Android扩展库。 有关更多信息，请阅读AndroidX公告。 在Android Studio 3.2中，使用新的重构功能可以帮助您完成此重构。 要将现有项目重构为AndroidX，请选择Refactor &gt; Refactor to AndroidX。 如果您使用了任何未迁移到AndroidX的Maven依赖包，Android Studio构建系统也会自动转换这些项目依赖包。 Android Gradle插件提供了以下全局flag，您可在gradle.properties文件中设置这些标志： android.useAndroidX：当设置为true时，表明使用AndroidX。如果未设置该标志，Android Studio默认其为false。 android.enableJetifier：当设置为true时，表示您希望有工具（来自Android Gradle插件）自动将现有的第三方库转换支持AndroidX的库。如果未设置该标志，Android Studio默认其为false。 如果您还不想迁移至AndroidX，请将两个标志设置为false，或者干脆不设置。 当您使用Refactor to AndroidX命令，或者创建一个minSdkVersion为“P”的新项目时，这两个标志都需要设置为true。 重要提示：在当前的Android Studio 3.2 Canary版本中，存在一个已知问题，它将导致在您使用创建新项目New Project时不会自动设置android.useAndroidX标志。所以，您目前需要在gradle.properties文件中手动设置。 如果您想立即开始使用AndroidX库，并且不需要转换现有的第三方库，则可以将android.useAndroidX标志设置为true，并将android.enableJetifier标志设置为false。 Android App Bundle Android App Bundle是一种新的上传格式，其中包含应用程序的所有已编译代码和资源，但会延迟APK的生成和签名。 Google Play的新应用服务模型称为Dynamic Delivery动态投放，即使用您的App Bundle为每个用户的设备生成对应优化的APK，因此每个用户只需下载那些为了在其设备上运行app所需的代码和资源。 您不再需要构建，签名和管理多个APK，并且用户所需下载的东西更少、更优化。 此外，您可以将动态功能模块添加到您的应用项目中，并将其包含在App Bundle中。 通过动态投放，用户可以根据需要下载和安装动态功能。 要构建一个bundle包，请选择Build&gt; Build Bundle(s) / APK(s)&gt; Build Bundle(s)。 有关更多信息（包括构建和分析Android App Bundle的说明），请参阅Android App Bundle入门。 Layout Editor 布局编辑器中的示例数据 许多Android布局都在运行时才有数据填充，这使得在编码阶段，人们难以直观地查看到布局在运行时的样子。 您现在可以在布局编辑器中轻松查看填充了示例数据的布局预览。 添加View时，在Design窗口中，View下方会出现一个按钮点击此按钮可以设置设计时的视图属性。 您可以从各种示例数据模板中进行选择，并指定用于填充View的数据条数。 要尝试使用示例数据，请将RecyclerView添加到新布局里，单击视图下方的设计视图属性按钮，然后选择一个示例数据模板。 Slices 切片（暂译） Slices提供了一种将Android应用程序的部分功能嵌入到其他用户界面上的新方法。 例如，Slices可以在Google搜索建议中显示应用的功能和内容。 Android Studio 3.2具有的内置模板可帮助您使用新的Slice Provider API来扩展您的应用程序，还有新的lint检查可以确保在构建Slices时遵循最佳做法。 要开始使用Slice，请右键单击项目文件夹并选择 New &gt; Other &gt; Slice Provider。 要了解包括如何测试切片的交互等更多信息，请阅读Slices入门指南。 IntelliJ IDEA 2018.1.1 Android Studio IDE的核心已经通过2018.1.1版本的IntelliJ IDEA进行了改进。 Android profilers分析器 请在Android Studio的最新版本3.2上尝试以下新的Android Profiler功能。 Energy Profiler 能耗分析器Energy Profiler可视化地显示应用程序的预估耗能情况。 当您在Android 8.0（API 26）或更高版本的真机设备或Android模拟器上运行app时，Energy Profiler会在Profiler窗口底部显示一行新的信息。 点击Energy行可以最大化Energy Profiler视图。将鼠标指针放在时间线上的条形图时，可查看CPU、网络和位置（GPS）以及系统事件（如唤醒锁，警报和作业）的能源使用情况。 Sessions 会话您现在可以将Profiler数据保存为“会话”以便稍后重新查看。 （分析器会保留会话数据直到您重新启动IDE。） 通过从主菜单中选择Run &gt; Profile来运行app后，可以单击加号 + 并从下拉菜单中选择一个进程来启动一个新的会话，如下所示。 当您录制method trace方法轨迹或捕获heap dump时，IDE会将这些数据（连同app的网络活动信息）作为单个条目添加到当前会话中，并且您可以轻松地在录制数据之间来回切换以比较数据。要停止向当前会话添加数据，请单击。 System Trace 系统信息轨迹在CPU profiler分析器中，选择新的System Trace系统轨迹配置以检查设备的系统CPU和线程活动。 此跟踪配置基于systrace构建，适用于调查系统级问题，如UI闪烁掉帧。 在使用这种新的轨迹配置时，您可以通过在代码中使用Trace类直观地在Profiler时间线中标记重要的代码行程。 在内存分析器Memory Profiler中检查JNI引用如果您的app在Android 8.0（API级别26）或更高级别的设备上运行，则可以使用Memory Profiler检查App JNI代码的内存分配情况。 在您的App在运行时，选择您想要检查的时间区间，然后从类列表上方的下拉菜单中选择JNI堆，如下所示。 然后，您可以像平常一样检查堆中的对象，并在Allocation Call Stack调用堆栈分配页中双击对象以查看JNI引用对象在您的代码中分配和释放的位置。 在App启动期间记录CPU活动您现在可以在App启动期间记录CPU活动，如下所示： 从主菜单中选择Run &gt; Edit Configurations。 在所需运行配置的Profiling性能分析选项卡下，选中Start recording a method trace on startup 启动时记录方法轨迹。 从下拉菜单中选择要使用的CPU记录配置。 选择Run &gt; Profile将应用程序部署到Android 8.0（API级别26）或更高版本的设备上。 导出CPU跟踪在使用CPU分析器记录CPU活动后，可以将数据导出为.trace文件以与其他人共享或者留作以后检查。 要导出trace文件，请执行以下操作： 右键单击CPU时间轴以导出对应区域的记录。 从下拉菜单中选择Export trace导出轨迹。 选择要保存文件的位置，然后单击Save保存。 导入并检查CPU trace文件使用Debug API或CPU profiler创建.trace文件后，可以导入并检查。 （目前，您不能导入System Trace recordings系统跟踪记录。） 要导入您的trace文件，单击Profiler的Sessions窗口中的Start new profiler session +，然后选择Load from file从文件加载。然后，您可以在CPU分析器中检查其数据，其操作类似于其他检查操作，但有一些例外情况： CPU活动不是沿着CPU时间轴表示的。 线程活动时间线仅表示每个线程可用的跟踪数据的位置，而不是实际的线程状态（如正在运行、正在等待或正在休眠）。 使用调试API记录CPU活动您现在可以通过调试API，来让CPU分析器启动和停止记录CPU活动。设备运行App后，当调用startMethodTracing(String tracePath)时，分析器会自动开始记录CPU活动，当调用stopMethodTracing()时，分析器停止记录。在记录使用此API触发的记录CPU活动时，CPU分析器将调试API选定为CPU记录配置。 Lint检查 Android Studio 3.2包含许多用于lint检查的新功能和改进。 Lint会检查Java/Kotlin的互操作性为了确保您的Java代码与Kotlin代码直接拥有良好的互操作性（互相使用、修改），新的lint检查会强制执行Kotlin Interop Guide互操作指南中介绍的最佳实践规范。 这些检查范围将包括：Nullability注释的使用、Kotlin硬关键字、lambda参数的位置等等。 要启用这些检查，请至File &gt; Preferences &gt; Editor &gt; Inspections并检查您要在Kotlin Interoperability互用性下启用的规则，如下所示。 然后，您可以通过从主菜单中选择Analyze&gt; Inspect Code运行检查。 要在使用命令行构建时，启用这些检查，请将以下内容添加到build.gradle文件中： 12345android &#123; lintOptions &#123; check &apos;Interoperability&apos; &#125;&#125; 更多lint检查除了上一节中介绍的lint对于Kotlin互操作性的检查之外，Android Studio 3.2还实现了20个新的检查，以帮助您查找和识别常见的代码问题。这些检查的范围，从潜在的使用错误的警告到高优先级安全漏洞错误都有涉及。 新的Gradle目标使用新的Gradle任务lintFix，可直接按照lint对于源码给出的safe安全修改建议进行全局修改。比如SyntheticAccessor就是其中一种安全修改的lint检查。 Metadata元数据更新已更新各种Metadata元数据（如服务转换检查），使lint检查能在Android P开发者预览版上使用。 如果在新版本上运行Lint，则会发出警告现在，Lint会保存正在使用的基准值对应的variant变体和版本，如果您运行了一个不同的变体，lint则会发出警告。（译者注：即不同构建变体可能需要对应不同规则的lint） Lint检查的一些改进Android Studio 3.2包含了关于现有lint检查的许多改进。例如，资源循环检查现在可适用于其他的资源类型，翻译检测器则可以在编辑器中实时发现缺少翻译的问题。 问题ID更明显问题ID现在会显示在更多的位置上，包括显示在Inspection Results 检查结果窗口中，这使您可以更轻松地找相关信息，并通过build.gradle中的lintOptions选项启用或禁用其检查功能。 有关更多信息，请参阅通过Gradle配置Lint选项。 Data Binding V2 Data Binding V2现在默认启用并且与V1相兼容， 所以使用Data Binding V2的工程可以使用V1编译的依赖库。 但是请注意，使用V1的工程无法使用通过V2编译的依赖 D8编译器的Desugaring 在Android Studio 3.1中，我们将desugaring作为实验性功能整合到了D8工具中，（译者注：Desugaring是将语法糖转换为编译器可以更高效处理的形式的一种特性），从而缩短了整体编译时间。 现在，在Android Studio 3.2中，D8会默认打开。 新的代码优化器 R8是一种替代ProGuard用来压缩代码和混淆的新工具。 您可以通过在项目的gradle.properties文件中输入以下内容来使用R8的预览版本： 1android.enableR8 = true ABI平台编译不同APK的变化 默认情况下，构建多个使用不同ABI的APK时，插件不再默认地为以下的ABI平台生成APK：mips、mips64和armeabi。 如果您想构建这些ABI平台的APK，则必须使用NDK r16b或更低版本，并在build.gradle文件中指定ABI，如下所示： 123456splits &#123; abi &#123; include &apos;armeabi&apos;, &apos;mips&apos;, &apos;mips64&apos; ... &#125;&#125; ※注意：此改动在Android Studio 3.1 RC1和更高版本中也有。 查看外部头文件 在以前版本的Android Studio中，使用Project项目视图时，只能查看和检查那些本地构建的库的头文件。 在新版本，您现在还可以查看和检查那些项目外部的C / C ++依赖库的头文件。 如果您的项目中已包含C / C ++代码和库，从主菜单中选择View &gt; Tool Windows &gt; Project并选择Android，可以打开IDE左侧的Project窗口。 在cpp文件夹中，项目内的所有头文件都在每个本地C / C ++库的include节点下，如下所示。 Native Multidex将默认启用 在Android API为21或更高版本的设备上运行Debug版本App时，之前版本的Android Studio启用了Native Multidex。 现在，无论您是在设备运行还是编译release版本的APK，对于minSdkVersion = 21或更高版本的所有模块，Gradle插件都会为其开启Native Multidex功能。 AAPT2转移到Google的Maven存储库 从Android Studio 3.2 Canary 11开始，AAPT2（Android Asset Packaging Tool 2）的源码是从Google的Maven库拉取的。 要使用AAPT2，请确保您的build.gradle文件中具有google()的依赖，如下所示： 12345678910111213buildscript &#123; repositories &#123; google() // here jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.0-alpha12&apos; &#125; &#125; allprojects &#123; repositories &#123; google() // and here jcenter() &#125; AAPT2作为新版本修复了许多错误，其中对在Windows中非ASCII码字符的处理做了改进。 ADB连接助手 新的ADB连接助手提供了分步说明，以帮助您通过Android Debug Bridge调试桥（ADB）连接和使用设备。 要启动助理，请选择Tools &gt; Connection Assistant。 Assistant辅助面板的一系列页面中，ADB连接助手会显示说明指南、上下文控制以及连接的设备列表这些信息。 模拟器的改进 您现在可以随时在Android模拟器中保存和加载AVD（Android虚拟设备）的快照snapshot，因此可以快速轻松地将模拟器返回到已知状态，从而进行测试。 当您使用AVD管理器来编辑AVD时，您可以指定在AVD启动时加载哪个AVD快照。 在模拟器Extended controls扩展控件窗口的Snapshots快照选项卡中，可以保存、加载和管理AVD快照。 有关详细信息，请参阅Android模拟器27.3.0 Canary发布说明。]]></content>
  </entry>
</search>
